<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[POJ-2456 Aggressive cows（贪心+二分 水题）]]></title>
    <url>%2F2018%2F08%2F02%2FPOJ-2456%2F</url>
    <content type="text"><![CDATA[描述传送门：POJ-2456 Aggressive cows Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance? 输入描述 Line 1: Two space-separated integers: N and C Lines 2..N+1: Line i+1 contains an integer stall location, xi 输出描述 Line 1: One integer: the largest minimum distance 示例输入1234565 312849 输出13 HintOUTPUT DETAILS: FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. Huge input data,scanf is recommended. 题解题目大意有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。 思路先排序，再二分枚举相邻两牛的间距，判断大于等于此间距下能否放进所有的牛。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define LL long longconst int INF = 0x3f3f3f3f;const int MAXN = 1e5 +10;using namespace std;int a[MAXN];int n, c;bool Judge(int m)&#123; int last = 0; for(int i = 1; i &lt; c; i++)&#123; int crt = last+1; while(crt &lt; n &amp;&amp; a[crt] -a[last] &lt; m)&#123; crt++; &#125; if(crt == n)&#123; return false; &#125; last = crt; &#125; return true;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;c); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); &#125; sort(a, a+n); int l = 0,r = INF; while(1 &lt; r-l)&#123; int mid = (l+r)&gt;&gt;1; if(Judge(mid))&#123; l = mid; &#125; else&#123; r = mid; &#125; &#125; printf("%d", l);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>基础技巧</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1321 棋盘问题（DFS 水题）]]></title>
    <url>%2F2018%2F08%2F02%2FPOJ-1321%2F</url>
    <content type="text"><![CDATA[描述传送门：POJ-1321 棋盘问题 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 输入描述输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 输出描述对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 示例输入1234567892 1#..#4 4...#..#..#..#...-1 -1 输出1221 题解题目大意中文题面 思路DFS累计可行的方案数，因为题目要求不可以将棋子摆放在同一行和同一列，所以走过一列就把它标记下来下次的时候就不可以再摆放在这一列。然后就从下一行开始寻找可行的地方，直到摆放的棋子数与被要求摆放的棋子数相同时，就将方案数进行一次++，然后再进行递归下去。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 10;using namespace std;int n, k, cnt;int book[MAXN];char MAP[MAXN][MAXN];void dfs(int x, int y)&#123; if(y &gt;= k)&#123; cnt++; return; &#125; for(int i = x; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(MAP[i][j] == '#' &amp;&amp; !book[j])&#123; book[j] = 1; dfs(i+1, y+1); book[j] = 0; &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; k)&#123; if(n == -1 &amp;&amp; k == -1) break; memset(book, 0, sizeof(book)); for(int i = 0; i &lt; n; i++) cin &gt;&gt;MAP[i]; cnt = 0; dfs(0, 0); cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FZU-2150 Fire Game(双BFS)]]></title>
    <url>%2F2018%2F08%2F02%2FFZU-2150-Fire-Game%2F</url>
    <content type="text"><![CDATA[描述传送门：FZU-2150 Fire Game text url Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire. As we all know, the fire can spread among the grass. If the grid (x, y) is firing at time t, the grid which is adjacent to this grid will fire at time t+1 which refers to the grid (x+1, y), (x-1, y), (x, y+1), (x, y-1). This process ends when no new grid get fire. If then all the grid which are consisting of grass is get fired, Fat brother and Maze will stand in the middle of the grid and playing a MORE special (hentai) game. (Maybe it’s the OOXX game which decrypted in the last problem, who knows.) You can assume that the grass in the board would never burn out and the empty grid would never get fire. Note that the two grids they choose can be the same. 输入描述The first line of the date is an integer T, which is the number of the text cases. Then T cases follow, each case contains two integers N and M indicate the size of the board. Then goes N line, each line with M character shows the board. “#” Indicates the grass. You can assume that there is at least one grid which is consisting of grass in the board. 1 &lt;= T &lt;=100, 1 &lt;= n &lt;=10, 1 &lt;= m &lt;=10 输出描述For each case, output the case number first, if they can play the MORE special (hentai) game (fire all the grass), output the minimal time they need to wait after they set fire, otherwise just output -1. See the sample input and output for more details. 示例输入123456789101112131415161743 3.#.###.#.3 3.#.#.#.#.3 3...#.#...3 3###..##.# 输出1234Case 1: 1Case 2: -1Case 3: 0Case 4: 2 题解题目大意俩小孩放火，只有‘#’格子可燃，两人同时各点燃一个‘#’（可以是同一个），火可以向上向下向左向右在有草的格子蔓延，点火的地方时间为0，蔓延至下一格的时间依次加一，问最快多久能烧完‘#’，如不能烧完则输出“-1”。 思路依次枚举两个‘#’，然后双路BFS，同时维护最小时间min 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LL long longconst int MAXN = 15, INF = 0x3f3f3f3f;using namespace std;int dx[] = &#123;1, -1, 0, 0&#125;;int dy[] = &#123;0, 0, 1, -1&#125;;int n, m;char MAP[MAXN][MAXN];int vis[MAXN][MAXN], book[MAXN][MAXN];struct node&#123; int x, y; &#125;now, nex;int bfs(int x1, int y1, int x2, int y2)&#123; memset(vis, INF, sizeof(vis)); queue&lt;node&gt; que; vis[x1][y1] = 0; vis[x2][y2] = 0; now.x = x1; now.y = y1; que.push(now); now.x = x2; now.y = y2; que.push(now); int res = 0; while(!que.empty())&#123; now = que.front(); que.pop(); for(int i = 0; i &lt; 4; i++)&#123; int xx = now.x+dx[i], yy = now.y+dy[i]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; MAP[xx][yy] == '#' &amp;&amp; vis[xx][yy] &gt; vis[now.x][now.y]+1)&#123; vis[xx][yy] = vis[now.x][now.y]+1; nex.x = xx; nex.y = yy; que.push(nex); &#125; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(MAP[i][j] == '#')&#123; res = max(res, vis[i][j]); &#125; &#125; &#125; return res;&#125;int main()&#123; int t, ans; cin &gt;&gt; t; for(int d = 1; d &lt;= t; d++)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++)&#123; cin &gt;&gt; MAP[i]; &#125; int temp; ans = INF; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(MAP[i][j] == '#')&#123; for(int k = 0; k &lt; n; k++)&#123; for(int g = 0; g &lt; m; g++)&#123; if(MAP[k][g] == '#')&#123; temp = bfs(i, j, k, g); ans = min(ans, temp); &#125; &#125; &#125; &#125; &#125; &#125; if(ans == INF) ans = -1; cout &lt;&lt; "Case " &lt;&lt; d &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1241 Oil Deposits(BFS||DFS 水题)]]></title>
    <url>%2F2018%2F08%2F02%2FHDU-1241%20Oil%20Deposits%20%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-1241 Oil Deposits The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. 输入描述The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or `@’, representing an oil pocket. 输出描述For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. 示例输入1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0 输出12340122 题解题目大意判断有多少个‘@’的联通块，八个方向有接触就算在同一联通块内。 思路搜索入门题，直接暴力枚举每个点，DFS、BFS都可以，把搜索到的点标记下，维护下num标记即可。 代码BFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LL long longconst int MAXN = 110;using namespace std;int dx[] = &#123;1, -1, 0, 0, 1, 1, -1, -1&#125;;int dy[] = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;;int m, n;char MAP[MAXN][MAXN];typedef pair&lt;int, int&gt;p;p e;void bfs(int x, int y)&#123; queue&lt;p&gt; que; que.push(p(x, y)); MAP[x][y] = '*'; while(!que.empty())&#123; e = que.front(); que.pop(); for(int i = 0; i &lt; 8; i++)&#123; int xx = e.first+dx[i], yy = e.second+dy[i]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; MAP[xx][yy] == '@')&#123; MAP[xx][yy] = '*'; que.push(p(xx, yy)); &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(m == 0 &amp;&amp; n == 0) break; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; cin &gt;&gt;MAP[i][j]; &#125; &#125; int cnt = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(MAP[i][j] == '@')&#123; bfs(i, j); cnt++; &#125; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; DFS123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100+10;int m,n,flag[MAXN][MAXN];char MAP[MAXN][MAXN];void dfs(int a,int b,int rt)&#123; if(a&lt;0 || b&lt;0 || a&gt;=m || b&gt;=n) return; if(flag[a][b]&gt;0 || MAP[a][b] != '@') return; flag[a][b] = rt; for(int i = -1; i &lt;= 1; i++)&#123; for(int j = -1;j &lt;= 1; j++)&#123; if(i !=0 || j != 0) dfs(a+i, b+j, rt); &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n))&#123; if(m==0&amp;&amp;n==0) return 0; for(int i=0;i&lt;m;i++) scanf("%s", MAP[i]); memset(flag,0,sizeof(flag)); int sum=0; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++)&#123; if(flag[i][j]==0 &amp;&amp; MAP[i][j]=='@')&#123; dfs(i,j,++sum); &#125; &#125; &#125; printf("%d\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2612 Find a way（双BFS）]]></title>
    <url>%2F2018%2F08%2F02%2FHDU-2612-Find-a-way%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-2612 Find a way Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes. 输入描述The input contains multiple test cases.Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).Next n lines, each line included m character.‘Y’ express yifenfei initial position.‘M’ express Merceki initial position.‘#’ forbid road;‘.’ Road.‘@’ KCF 输出描述For each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet. 示例输入123456789101112131415164 4Y.#@.....#..@..M4 4Y.#@.....#..@#.M5 5Y..@..#....#...@..M.#...# 输出123668866 题解题目大意Y和M要去肯德基聚餐，图中有多个kfc，他们要选的那个kfc必须到彼此的所用时间之和最小，问最少需要多少时间。这里一格代表了11分钟。 思路以Y和M为起点各跑一次BFS，每个‘@’累加两次的最短路，最后遍历整张地图更新min。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 210, INF = 0x3f3f3f3f;using namespace std;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int n, m;char MAP[MAXN][MAXN];int used[MAXN][MAXN], vis[MAXN][MAXN], book[MAXN][MAXN];struct node &#123; int x, y, dis; &#125;now, nex, Y, M;void bfs(node e)&#123; memset(used, 0, sizeof(used)); queue&lt;node&gt; que; que.push(e); while(!que.empty())&#123; now = que.front(); que.pop(); if(MAP[now.x][now.y] == '@')&#123; vis[now.x][now.y] += now.dis; book[now.x][now.y]++; &#125; for(int i = 0; i &lt; 4; i++)&#123; int xx = now.x+dx[i], yy = now.y+dy[i]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; !used[xx][yy])&#123; if(MAP[xx][yy] != '#')&#123; nex.x = xx; nex.y = yy; nex.dis = now.dis+1; que.push(nex); used[xx][yy] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; memset(vis, 0, sizeof(vis)); memset(book, 0, sizeof(book)); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; cin &gt;&gt; MAP[i][j]; if(MAP[i][j] == 'Y')&#123; Y.x = i; Y.y = j; Y.dis = 0; &#125; if(MAP[i][j] == 'M')&#123; M.x = i; M.y = j; M.dis = 0; &#125; &#125; &#125; bfs(Y); bfs(M); int ans = INF; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(book[i][j] == 2)&#123; ans = min(ans, vis[i][j]); &#125; &#125; &#125; cout &lt;&lt; ans*11 &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Start coding now]]></title>
    <url>%2F2018%2F08%2F02%2FStart-coding-now%2F</url>
    <content type="text"><![CDATA[虽然从去年年底就有考虑搭个主页，但一直拖到现在，也挺久的。趁着这两天系楼断网就在寝室按照网上的各路教程搞了一个，终于结束了，哈哈哈哈哈～折腾一番，有了自己的博客，另外知道了一点 Git 的知识，收藏夹里多了很多大佬的博客。以后坚持写写题解，写点技术性的东西，也能防止自己又堕落。很少能做到坚持一件事超过一个月，希望这次能坚持写下去吧。 Start coding now. 第一次搭建博客，好多地方都还不完善，欢迎大佬指点。留言系统来必应实在太丑了，虽然Gitment只能用GitHub登录，但考虑到博客的访问人群，先忍忍，等过几天就换过去。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
