<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言培训总复习标程]]></title>
    <url>%2F2018%2F08%2F03%2FC%E8%AF%AD%E8%A8%80%E5%9F%B9%E8%AE%AD%E6%80%BB%E5%A4%8D%E4%B9%A0%E6%A0%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言不好意思，平时都是写C++，所以格式上可能和大家学的C有点出入。 A12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long int a, b; scanf("%lld %lld", &amp;a, &amp;b); printf("%lld", a+b);&#125; B1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); int sum = 0; for(int i = 1 ; i &lt;= n; i++)&#123; if( n % i ==0 )&#123; sum++; &#125; &#125; if(sum%2 ==0)&#123; puts("even"); &#125; else&#123; puts("odd"); &#125;&#125; C1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, num = 0, a[1010]; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); &#125; for(int i = 0; i &lt; n; i++)&#123; if(a[i] == 4 || a[i] == 3 || a[i]== 9 || a[i]== 6)&#123; num++; &#125; &#125; printf("%d", num);&#125; D1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char ch; int n, nb = 0, sb = 0, a[1010]; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf("%c", &amp;ch); if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')&#123; nb++; &#125; else&#123; sb++; &#125; &#125; if(sb &lt; nb)&#123; puts("ZHYNB"); &#125; else if(sb &gt; nb)&#123; puts("HSQSB"); &#125; else&#123; puts("ZCRZCR"); &#125;&#125; E1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int year, month, day; int date[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; scanf ("%d/%d/%d", &amp;year, &amp;month, &amp;day); int sum = 0; if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0)&#123; date[2]++; &#125; for (int i = 1; i &lt; month; i ++)&#123; sum += date[i]; &#125; sum += day; printf ("%d\n", sum);&#125; 扯淡大家真的是非常优秀，我去年是在军训时才打下自己的第一句Hello World，暑假啥也没学，啥也没看，所以很佩服大家。学习这事不要急，慢慢来，当时一个排序、一个打印菱形就能磕我一下午。但无论如何你最后选择了什么方向，大学都一定不要荒废。anyway，祝大家有一个充实的大学生活~–没错，我就是群里那个叫“何世全”的（感谢队友不杀之恩情）。]]></content>
      <categories>
        <category>题解</category>
        <category>标程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder-1175 拓扑排序·二（拓扑排序）]]></title>
    <url>%2F2018%2F08%2F03%2FHihoCoder-1175%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%C2%B7%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[描述传送门：HihoCoder-1175 拓扑排序·二 小Hi和小Ho所在学校的校园网被黑客入侵并投放了病毒。这事在校内BBS上立刻引起了大家的讨论，当然小Hi和小Ho也参与到了其中。从大家各自了解的情况中，小Hi和小Ho整理得到了以下的信息： 校园网主干是由N个节点(编号1..N)组成，这些节点之间有一些单向的网路连接。若存在一条网路连接(u,v)链接了节点u和节点v，则节点u可以向节点v发送信息，但是节点v不能通过该链接向节点u发送信息。在刚感染病毒时，校园网立刻切断了一些网络链接，恰好使得剩下网络连接不存在环，避免了节点被反复感染。也就是说从节点i扩散出的病毒，一定不会再回到节点i。当1个病毒感染了节点后，它并不会检查这个节点是否被感染，而是直接将自身的拷贝向所有邻居节点发送，它自身则会留在当前节点。所以一个节点有可能存在多个病毒。现在已经知道黑客在一开始在K个节点上分别投放了一个病毒。举个例子，假设切断部分网络连接后学校网络如下图所示，由4个节点和4条链接构成。最开始只有节点1上有病毒。 最开始节点1向节点2和节点3传送了病毒，自身留有1个病毒： 其中一个病毒到达节点2后，向节点3传送了一个病毒。另一个到达节点3的病毒向节点4发送自己的拷贝： 当从节点2传送到节点3的病毒到达之后，该病毒又发送了一份自己的拷贝向节点4。此时节点3上留有2个病毒： 最后每个节点上的病毒为： 小Hi和小Ho根据目前的情况发现一段时间之后，所有的节点病毒数量一定不会再发生变化。那么对于整个网络来说，最后会有多少个病毒呢？ 输入描述第1行：3个整数N,M,K，1≤K≤N≤100,000，1≤M≤500,000 第2行：K个整数A[i]，A[i]表示黑客在节点A[i]上放了1个病毒。1≤A[i]≤N 第3..M+2行：每行2个整数 u,v，表示存在一条从节点u到节点v的网络链接。数据保证为无环图。1≤u,v≤N 输出描述第1行：1个整数，表示最后整个网络的病毒数量 MOD 142857 示例输入1234564 4 111 21 32 33 4 输出16 题解题目大意中文题面 思路从入度为0的节点开始，对于这些节点，它并不会再增加病毒数量。那么我们就根据它所关联的连接将病毒分发出去，然后这个节点就没有作用了。那不妨就删掉好了，它所关联的边也删掉，这样图中又会产生一些新的没有入度的节点。这样一直删点，直到所有的点都被删掉，将所有点的病毒数量加起来就是总的病毒数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;const int MAXN = 5*1e5, INF = 0x3f3f3f3f, MOD = 142857;using namespace std;int n, m, k, u, v, x;int inDeg[MAXN], virus[MAXN];vector&lt;int&gt; E[MAXN];void topsort()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!inDeg[i]) q.push(i); while(!q.empty())&#123; int now = q.front(); q.pop(); for(int i = 0; i &lt; E[now].size(); i++)&#123; if(--inDeg[E[now][i]] == 0)&#123; q.push(E[now][i]); &#125; virus[E[now][i]] = (virus[E[now][i]] + virus[now])%MOD; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d %d", &amp;n, &amp;m, &amp;k))&#123; memset(inDeg, 0, sizeof(inDeg)); memset(virus, 0, sizeof(virus)); for(int i = 0; i &lt;= n; i++) E[i].clear(); for(int i = 0; i &lt; k; i++)&#123; scanf("%d", &amp;x); virus[x]++; &#125; for(int i = 0; i &lt; m; i++)&#123; scanf("%d %d", &amp;u, &amp;v); E[u].push_back(v); inDeg[v]++; &#125; topsort(); int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; ans = (ans + virus[i])%MOD; &#125; printf("%d\n", ans); &#125;&#125;/*4 4 111 21 32 33 4*/]]></content>
      <categories>
        <category>题解</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>TopSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder-1174 拓扑排序·一（拓扑序 判断循环图）]]></title>
    <url>%2F2018%2F08%2F03%2FHihoCoder-1174%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%C2%B7%E4%B8%80%2F</url>
    <content type="text"><![CDATA[描述传送门：HihoCoder-1174拓扑排序·一 我们都知道大学的课程是可以自己选择的，每一个学期可以自由选择打算学习的课程。唯一限制我们选课是一些课程之间的顺序关系：有的难度很大的课程可能会有一些前置课程的要求。比如课程A是课程B的前置课程，则要求先学习完A课程，才可以选择B课程。大学的教务收集了所有课程的顺序关系，但由于系统故障，可能有一些信息出现了错误。现在小Ho把信息都告诉你，请你帮小Ho判断一下这些信息是否有误。错误的信息主要是指出现了”课程A是课程B的前置课程，同时课程B也是课程A的前置课程”这样的情况。当然”课程A是课程B的前置课程，课程B是课程C的前置课程，课程C是课程A的前置课程”这类也是错误的。 输入描述第1行：1个整数T，表示数据的组数T(1 &lt;= T &lt;= 5)接下来T组数据按照以下格式：第1行：2个整数，N,M。N表示课程总数量，课程编号为1..N。M表示顺序关系的数量。1 &lt;= N &lt;= 100,000. 1 &lt;= M &lt;= 500,000第2..M+1行：每行2个整数，A,B。表示课程A是课程B的前置课程。 输出描述第1..T行：每行1个字符串，若该组信息无误，输出”Correct”，若该组信息有误，输出”Wrong”。 示例输入123456722 21 22 13 21 21 3 输出12WrongCorrect 题解题目大意中文题面 思路先扫描所有点和边维护每一个点的入度值，复杂度O(N+M)。 把入度为0的点加入队列Q中，当然有可能存在多个入度为0的点，同时它们之间也不会存在连接关系，所以按照任意顺序加入Q都是可以的。从Q中取出一个点p。对于每一个未删除且与p相连的点q，入度值-1；如果入读值为0，把q加入Q。不断重复第3步，直到Q为空。最后剩下的未被删除的点，也就是组成环的点了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;const int MAXN = 5*1e5, INF = 0x3f3f3f3f, MOD = 142857;using namespace std;int n, m, k, u, v, x;int inq[MAXN];vector&lt;int&gt; E[MAXN];bool topsort()&#123; queue&lt;int&gt; q; int num = 0; for(int i = 1; i &lt;= n; i++)&#123; if(!inq[i])&#123; q.push(i); &#125; &#125; while(!q.empty())&#123; int now = q.front(); q.pop(); num++; for(int i = 0; i &lt; E[now].size(); i++)&#123; if(--inq[E[now][i]] == 0)&#123; q.push(E[now][i]); &#125; &#125; &#125; if(num == n) return true; else return false;&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--)&#123; scanf("%d %d", &amp;n, &amp;m); memset(inq, 0, sizeof(inq)); for(int i = 0; i &lt;= n; i++) E[i].clear(); for(int i = 0; i &lt; m; i++)&#123; scanf("%d %d", &amp;u, &amp;v); E[u].push_back(v); inq[v]++; &#125; if(topsort()) puts("Correct"); else puts("Wrong"); &#125;&#125;/*22 21 22 13 21 21 3*/]]></content>
      <categories>
        <category>题解</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>拓扑序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3273 Monthly Expense（二分）]]></title>
    <url>%2F2018%2F08%2F03%2FPOJ-3273%20Monthly%20Expense%2F</url>
    <content type="text"><![CDATA[描述传送门：POJ-3273 Monthly Expense Farmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ moneyi ≤ 10,000) that he will need to spend each day over the next N (1 ≤ N ≤ 100,000) days. FJ wants to create a budget for a sequential set of exactly M (1 ≤ M ≤ N) fiscal periods called “fajomonths”. Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth. FJ’s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit. 输入描述Line 1: Two space-separated integers: N and MLines 2.. N+1: Line i+1 contains the number of dollars Farmer John spends on the ith day 输出描述Line 1: The smallest possible monthly limit Farmer John can afford to live with. 示例输入123456787 5100400300100500101400 输出1500 HintIf Farmer John schedules the months so that the first two days are a month, the third and fourth are a month, and the last three are their own months, he spends at most $500 in any month. Any other method of scheduling gives a larger minimum monthly limit. 题解题目大意分期：将N个账款分割成M个财务期，使得每个分期账款和的最大值最小。给出农夫在n天中每天的花费，要求把这n天分作m组，每组的天数必然是连续的，要求分得各组的花费之和应该尽可能地小，最后输出各组花费之和中的最大值。 思路最大值最小的问题，可以采用二分来解决，二分其中一个值，算另一个结果，找到上届或下届。在这个题中 二分组的最大花费，计算是不是可以分为m组，找出最小的花费。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;const int MAXN = 1e5 +10;const int INF = 0x3f3f3f3f;using namespace std;int n, m;int a[MAXN];bool Judge(int mid)&#123; int cnt = 0; for(int i = 0; i &lt; n;)&#123; if(mid &lt; a[i]) return false; int sum = 0; bool f = true; while(sum+a[i] &lt;= mid)&#123; sum += a[i++]; f = false; &#125; if(f)&#123; i++; &#125; cnt++; &#125; if(cnt &gt; m) return false; else return true;&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); &#125; int l = 1, r = INF; while(l &lt; r)&#123; int mid = (l+r) &gt;&gt;1; if(Judge(mid))&#123; r = mid; &#125; else&#123; l = mid+1; &#125; &#125; printf("%d", l);&#125;/*5 5100200300400500*/]]></content>
      <categories>
        <category>题解</category>
        <category>基础技巧</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1213 How Many Tables（并查集 模板）]]></title>
    <url>%2F2018%2F08%2F03%2FHDU-1213%20How%20Many%20Tables%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-1213 How Many Tables Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers. One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table. For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least. 输入描述The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases. 输出描述For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks. 示例输入1234567825 31 22 34 55 12 5 输出1224 题解题目大意要宴请一些客人，但是客人彼此之间并不是完全互相认识的，规定如果A认识B，且B认识C，则认为A,B,C互相认识，可以安排在同一桌，求需要安排的桌数。 思路并查集模板题，水题。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5;int Fa[MAXN];int Find(int x)&#123; if(Fa[x] == x) return x; else return Fa[x] = Find(Fa[x]);&#125;void unite(int x, int y)&#123; x = Find(x); y = Find(y); if(x == y) return; else&#123; Fa[x] = y; &#125;&#125;int main()&#123; int t, n, m, x, y; cin &gt;&gt;t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) Fa[i] = i; while(m--)&#123; cin &gt;&gt; x &gt;&gt; y; unite(x, y); &#125; int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; if(Fa[i] == i) ans++; &#125; printf("%d\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1875 畅通工程再续(建图 + Kruscal or Prim)]]></title>
    <url>%2F2018%2F08%2F03%2FHDU-1875%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-1875 畅通工程再续 相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 输入描述输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。 输出描述每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”. 示例输入123456782210 1020 2031 12 21000 1000 输出121414.2oh! 题解题目大意中文题面 思路先建图，之后就是最小生成树的模板题。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;const int MAXN = 105;using namespace std;int num[MAXN][2], F[MAXN];struct node&#123; int from, to; double val;&#125;E[MAXN*MAXN];double Dis(int x1, int y1, int x2, int y2)&#123; return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));&#125;bool cmp(node a, node b)&#123; return a.val &lt; b.val;&#125;int Find(int x)&#123; if(F[x] == x) return x; else return Find(F[x]);&#125;bool Merge(int x, int y)&#123; x = Find(x); y = Find(y); if(x == y) return false; else F[x] = y; return true;&#125;int main()&#123; int t, n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++)&#123; F[i] = i; &#125; int k = 0, cnt = 0; double res = 0; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; num[i][0] &gt;&gt; num[i][1]; for(int j = 0; j &lt; i; j++)&#123; E[k].from = i; E[k].to = j; double cost = Dis(num[i][0], num[i][1], num[j][0], num[j][1]); if(cost &gt;= 10 &amp;&amp; cost &lt;= 1000) E[k++].val = cost*100; &#125; &#125; sort(E, E+k, cmp); for(int i = 0; i &lt; k; i++)&#123; if(Merge(E[i].from, E[i].to))&#123; res += E[i].val; cnt++; &#125; &#125; if(cnt == n-1) printf("%.1f\n", res); else cout &lt;&lt; "oh!" &lt;&lt; endl; &#125;&#125;/*2210 1020 2031 12 21000 1000*/]]></content>
      <categories>
        <category>题解</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1874 畅通工程续（Dijkstra or Floyd or SPFA 模板题）]]></title>
    <url>%2F2018%2F08%2F03%2FHDU-1874%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-1874 畅通工程续 某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。 现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。 输入描述本题目包含多组数据，请处理到文件结束。每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。 输出描述对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1. 示例输入123456783 30 1 10 2 31 2 10 23 10 1 11 2 输出122-1 题解题目大意中文题面 思路最短路模板题，几种最短路的算法都能直接过。 代码Dijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int MAXN = 205, INF = 0x3f3f3f3f;using namespace std;int n, m;vector&lt;pair&lt;int, int&gt; &gt;E[MAXN];int d[MAXN], inq[MAXN];int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; memset(d, INF, sizeof(d)); memset(inq, 0, sizeof(inq)); for(int i = 0; i &lt; MAXN; i++) E[i].clear(); for(int i = 0; i &lt; m; i++)&#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; E[x].push_back(make_pair(y, z)); E[y].push_back(make_pair(x, z)); &#125; int s, t; cin &gt;&gt; s &gt;&gt; t; queue&lt;int&gt; que; que.push(s); d[s] = 0; inq[s] = 1; while(!que.empty())&#123; int now = que.front(); que.pop(); inq[now] = 0; for(int i = 0; i &lt; E[now].size(); i++)&#123; int v = E[now][i].first; if(d[v] &gt; d[now] + E[now][i].second)&#123; d[v] = d[now] + E[now][i].second; if(inq[v]) continue; inq[v] = 0; que.push(v); &#125; &#125; &#125; if(d[t] == INF) d[t] = -1; cout &lt;&lt; d[t] &lt;&lt; endl; &#125;&#125; Floyd123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;const int MAXN = 205, INF = 0x3f3f3f3f;using namespace std;int n, m;int mp[MAXN][MAXN];int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == j) mp[i][j] = 0; else mp[i][j] = INF; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; mp[x][y] = min(z, mp[x][y]); mp[y][x] = min(z, mp[y][x]); &#125; int s, t; cin &gt;&gt; s &gt;&gt;t; for(int k = 0; k &lt; n; k++) for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) mp[i][j] = min(mp[i][k]+mp[k][j], mp[i][j]); if(mp[s][t] == INF) cout &lt;&lt; "-1" &lt;&lt;endl; else cout &lt;&lt; mp[s][t] &lt;&lt; endl; &#125;&#125; SPFA12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;const int MAXN = 205, INF = 0x3f3f3f3f;using namespace std;int n, m, s, t;int inq[MAXN], dis[MAXN];vector&lt;pair&lt;int, int&gt; &gt;E[MAXN];int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m))&#123; memset(dis, INF, sizeof(dis)); memset(inq, 0, sizeof(inq)); for(int i = 0; i &lt; MAXN; i++) E[i].clear(); for(int i = 0; i &lt; m; i++)&#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); E[x].push_back(make_pair(y, z)); E[y].push_back(make_pair(x, z)); &#125; scanf("%d %d", &amp;s, &amp;t); queue&lt;int&gt; que; dis[s] = 0; que.push(s); inq[s] = 1; while(!que.empty())&#123; int now = que.front(); que.pop();inq[now] = 0; for(int i = 0; i &lt; E[now].size(); i++)&#123; int v = E[now][i].first; if(dis[v] &gt; dis[now] + E[now][i].second)&#123; dis[v] = dis[now] + E[now][i].second; if(inq[v]) continue; inq[v] = 1; que.push(v); &#125; &#125; &#125; if(dis[t] == INF) printf("-1\n"); else printf("%d\n", dis[t]); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1232 畅通工程（并查集）]]></title>
    <url>%2F2018%2F08%2F03%2FHDU-1232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-1232 畅通工程 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 输入描述测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 输出描述对每个测试用例，在1行里输出最少还需要建设的道路数目。 示例输入1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 输出1234102998 HintHuge input, scanf is recommended. 题解题目大意中文题面 思路最小生成树的边为n-1。初始化时每个城镇都没有路，所以要连接的路的数量为n-1个，一次判断两个城镇是否在一个集合内，若不在同一集合内则建边，并入同一集合中。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;const int MAXN = 1e3 +5;using namespace std;int n, m;int F[MAXN];int Find(int x)&#123; if(F[x] == x) return x; else return Find(F[x]);&#125;bool Merge(int x, int y)&#123; x = Find(x); y = Find(y); if(x == y) return false; else F[x] = y; return true;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; if(!n) break; for(int i = 0; i &lt;= n; i++) F[i] = i; scanf("%d", &amp;m); int res = n-1; for(int i = 0; i &lt; m; i++)&#123; int x, y; scanf("%d %d", &amp;x, &amp;y); if(Merge(x, y))&#123; res--; &#125; &#125; printf("%d\n", res); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2456 Aggressive cows（贪心+二分 水题）]]></title>
    <url>%2F2018%2F08%2F02%2FPOJ-2456%20Aggressive%20cows%2F</url>
    <content type="text"><![CDATA[描述传送门：POJ-2456 Aggressive cows Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance? 输入描述 Line 1: Two space-separated integers: N and C Lines 2..N+1: Line i+1 contains an integer stall location, xi 输出描述 Line 1: One integer: the largest minimum distance 示例输入1234565 312849 输出13 HintOUTPUT DETAILS: FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. Huge input data,scanf is recommended. 题解题目大意有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。 思路先排序，再二分枚举相邻两牛的间距，判断大于等于此间距下能否放进所有的牛。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define LL long longconst int INF = 0x3f3f3f3f;const int MAXN = 1e5 +10;using namespace std;int a[MAXN];int n, c;bool Judge(int m)&#123; int last = 0; for(int i = 1; i &lt; c; i++)&#123; int crt = last+1; while(crt &lt; n &amp;&amp; a[crt] -a[last] &lt; m)&#123; crt++; &#125; if(crt == n)&#123; return false; &#125; last = crt; &#125; return true;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;c); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); &#125; sort(a, a+n); int l = 0,r = INF; while(1 &lt; r-l)&#123; int mid = (l+r)&gt;&gt;1; if(Judge(mid))&#123; l = mid; &#125; else&#123; r = mid; &#125; &#125; printf("%d", l);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>基础技巧</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1321 棋盘问题（DFS 水题）]]></title>
    <url>%2F2018%2F08%2F02%2FPOJ-1321%20%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[描述传送门：POJ-1321 棋盘问题 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 输入描述输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 输出描述对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 示例输入1234567892 1#..#4 4...#..#..#..#...-1 -1 输出1221 题解题目大意中文题面 思路DFS累计可行的方案数，因为题目要求不可以将棋子摆放在同一行和同一列，所以走过一列就把它标记下来下次的时候就不可以再摆放在这一列。然后就从下一行开始寻找可行的地方，直到摆放的棋子数与被要求摆放的棋子数相同时，就将方案数进行一次++，然后再进行递归下去。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 10;using namespace std;int n, k, cnt;int book[MAXN];char MAP[MAXN][MAXN];void dfs(int x, int y)&#123; if(y &gt;= k)&#123; cnt++; return; &#125; for(int i = x; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(MAP[i][j] == '#' &amp;&amp; !book[j])&#123; book[j] = 1; dfs(i+1, y+1); book[j] = 0; &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; k)&#123; if(n == -1 &amp;&amp; k == -1) break; memset(book, 0, sizeof(book)); for(int i = 0; i &lt; n; i++) cin &gt;&gt;MAP[i]; cnt = 0; dfs(0, 0); cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FZU-2150 Fire Game(双BFS)]]></title>
    <url>%2F2018%2F08%2F02%2FFZU-2150-Fire-Game%2F</url>
    <content type="text"><![CDATA[描述传送门：FZU-2150 Fire Game text url Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire. As we all know, the fire can spread among the grass. If the grid (x, y) is firing at time t, the grid which is adjacent to this grid will fire at time t+1 which refers to the grid (x+1, y), (x-1, y), (x, y+1), (x, y-1). This process ends when no new grid get fire. If then all the grid which are consisting of grass is get fired, Fat brother and Maze will stand in the middle of the grid and playing a MORE special (hentai) game. (Maybe it’s the OOXX game which decrypted in the last problem, who knows.) You can assume that the grass in the board would never burn out and the empty grid would never get fire. Note that the two grids they choose can be the same. 输入描述The first line of the date is an integer T, which is the number of the text cases. Then T cases follow, each case contains two integers N and M indicate the size of the board. Then goes N line, each line with M character shows the board. “#” Indicates the grass. You can assume that there is at least one grid which is consisting of grass in the board. 1 &lt;= T &lt;=100, 1 &lt;= n &lt;=10, 1 &lt;= m &lt;=10 输出描述For each case, output the case number first, if they can play the MORE special (hentai) game (fire all the grass), output the minimal time they need to wait after they set fire, otherwise just output -1. See the sample input and output for more details. 示例输入123456789101112131415161743 3.#.###.#.3 3.#.#.#.#.3 3...#.#...3 3###..##.# 输出1234Case 1: 1Case 2: -1Case 3: 0Case 4: 2 题解题目大意俩小孩放火，只有‘#’格子可燃，两人同时各点燃一个‘#’（可以是同一个），火可以向上向下向左向右在有草的格子蔓延，点火的地方时间为0，蔓延至下一格的时间依次加一，问最快多久能烧完‘#’，如不能烧完则输出“-1”。 思路依次枚举两个‘#’，然后双路BFS，同时维护最小时间min 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LL long longconst int MAXN = 15, INF = 0x3f3f3f3f;using namespace std;int dx[] = &#123;1, -1, 0, 0&#125;;int dy[] = &#123;0, 0, 1, -1&#125;;int n, m;char MAP[MAXN][MAXN];int vis[MAXN][MAXN], book[MAXN][MAXN];struct node&#123; int x, y; &#125;now, nex;int bfs(int x1, int y1, int x2, int y2)&#123; memset(vis, INF, sizeof(vis)); queue&lt;node&gt; que; vis[x1][y1] = 0; vis[x2][y2] = 0; now.x = x1; now.y = y1; que.push(now); now.x = x2; now.y = y2; que.push(now); int res = 0; while(!que.empty())&#123; now = que.front(); que.pop(); for(int i = 0; i &lt; 4; i++)&#123; int xx = now.x+dx[i], yy = now.y+dy[i]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; MAP[xx][yy] == '#' &amp;&amp; vis[xx][yy] &gt; vis[now.x][now.y]+1)&#123; vis[xx][yy] = vis[now.x][now.y]+1; nex.x = xx; nex.y = yy; que.push(nex); &#125; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(MAP[i][j] == '#')&#123; res = max(res, vis[i][j]); &#125; &#125; &#125; return res;&#125;int main()&#123; int t, ans; cin &gt;&gt; t; for(int d = 1; d &lt;= t; d++)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++)&#123; cin &gt;&gt; MAP[i]; &#125; int temp; ans = INF; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(MAP[i][j] == '#')&#123; for(int k = 0; k &lt; n; k++)&#123; for(int g = 0; g &lt; m; g++)&#123; if(MAP[k][g] == '#')&#123; temp = bfs(i, j, k, g); ans = min(ans, temp); &#125; &#125; &#125; &#125; &#125; &#125; if(ans == INF) ans = -1; cout &lt;&lt; "Case " &lt;&lt; d &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1241 Oil Deposits(BFS or DFS 水题)]]></title>
    <url>%2F2018%2F08%2F02%2FHDU-1241%20Oil%20Deposits%20%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-1241 Oil Deposits The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. 输入描述The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or `@’, representing an oil pocket. 输出描述For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. 示例输入1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0 输出12340122 题解题目大意判断有多少个‘@’的联通块，八个方向有接触就算在同一联通块内。 思路搜索入门题，直接暴力枚举每个点，DFS、BFS都可以，把搜索到的点标记下，维护下num标记即可。 代码BFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LL long longconst int MAXN = 110;using namespace std;int dx[] = &#123;1, -1, 0, 0, 1, 1, -1, -1&#125;;int dy[] = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;;int m, n;char MAP[MAXN][MAXN];typedef pair&lt;int, int&gt;p;p e;void bfs(int x, int y)&#123; queue&lt;p&gt; que; que.push(p(x, y)); MAP[x][y] = '*'; while(!que.empty())&#123; e = que.front(); que.pop(); for(int i = 0; i &lt; 8; i++)&#123; int xx = e.first+dx[i], yy = e.second+dy[i]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; MAP[xx][yy] == '@')&#123; MAP[xx][yy] = '*'; que.push(p(xx, yy)); &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(m == 0 &amp;&amp; n == 0) break; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; cin &gt;&gt;MAP[i][j]; &#125; &#125; int cnt = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(MAP[i][j] == '@')&#123; bfs(i, j); cnt++; &#125; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; DFS123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100+10;int m,n,flag[MAXN][MAXN];char MAP[MAXN][MAXN];void dfs(int a,int b,int rt)&#123; if(a&lt;0 || b&lt;0 || a&gt;=m || b&gt;=n) return; if(flag[a][b]&gt;0 || MAP[a][b] != '@') return; flag[a][b] = rt; for(int i = -1; i &lt;= 1; i++)&#123; for(int j = -1;j &lt;= 1; j++)&#123; if(i !=0 || j != 0) dfs(a+i, b+j, rt); &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n))&#123; if(m==0&amp;&amp;n==0) return 0; for(int i=0;i&lt;m;i++) scanf("%s", MAP[i]); memset(flag,0,sizeof(flag)); int sum=0; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++)&#123; if(flag[i][j]==0 &amp;&amp; MAP[i][j]=='@')&#123; dfs(i,j,++sum); &#125; &#125; &#125; printf("%d\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2612 Find a way（双BFS）]]></title>
    <url>%2F2018%2F08%2F02%2FHDU-2612-Find-a-way%2F</url>
    <content type="text"><![CDATA[描述传送门：HDU-2612 Find a way Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes. 输入描述The input contains multiple test cases.Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).Next n lines, each line included m character.‘Y’ express yifenfei initial position.‘M’ express Merceki initial position.‘#’ forbid road;‘.’ Road.‘@’ KCF 输出描述For each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet. 示例输入123456789101112131415164 4Y.#@.....#..@..M4 4Y.#@.....#..@#.M5 5Y..@..#....#...@..M.#...# 输出123668866 题解题目大意Y和M要去肯德基聚餐，图中有多个kfc，他们要选的那个kfc必须到彼此的所用时间之和最小，问最少需要多少时间。这里一格代表了11分钟。 思路以Y和M为起点各跑一次BFS，每个‘@’累加两次的最短路，最后遍历整张地图更新min。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 210, INF = 0x3f3f3f3f;using namespace std;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int n, m;char MAP[MAXN][MAXN];int used[MAXN][MAXN], vis[MAXN][MAXN], book[MAXN][MAXN];struct node &#123; int x, y, dis; &#125;now, nex, Y, M;void bfs(node e)&#123; memset(used, 0, sizeof(used)); queue&lt;node&gt; que; que.push(e); while(!que.empty())&#123; now = que.front(); que.pop(); if(MAP[now.x][now.y] == '@')&#123; vis[now.x][now.y] += now.dis; book[now.x][now.y]++; &#125; for(int i = 0; i &lt; 4; i++)&#123; int xx = now.x+dx[i], yy = now.y+dy[i]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; !used[xx][yy])&#123; if(MAP[xx][yy] != '#')&#123; nex.x = xx; nex.y = yy; nex.dis = now.dis+1; que.push(nex); used[xx][yy] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; memset(vis, 0, sizeof(vis)); memset(book, 0, sizeof(book)); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; cin &gt;&gt; MAP[i][j]; if(MAP[i][j] == 'Y')&#123; Y.x = i; Y.y = j; Y.dis = 0; &#125; if(MAP[i][j] == 'M')&#123; M.x = i; M.y = j; M.dis = 0; &#125; &#125; &#125; bfs(Y); bfs(M); int ans = INF; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(book[i][j] == 2)&#123; ans = min(ans, vis[i][j]); &#125; &#125; &#125; cout &lt;&lt; ans*11 &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Start coding now]]></title>
    <url>%2F2018%2F08%2F02%2FStart-coding-now%2F</url>
    <content type="text"><![CDATA[虽然从去年年底就有考虑搭个主页，但一直拖到现在，也挺久的。趁着这两天系楼断网就在寝室按照网上的各路教程搞了一个，终于结束了，哈哈哈哈哈～折腾一番，有了自己的博客，另外知道了一点 Git 的知识，收藏夹里多了很多大佬的博客。以后坚持写写题解，写点技术性的东西，也能防止自己又堕落。很少能做到坚持一件事超过一个月，希望这次能坚持写下去吧。 Start coding now. 第一次搭建博客，好多地方都还不完善，欢迎大佬指点。留言系统来必应实在太丑了，虽然Gitment只能用GitHub登录，但考虑到博客的访问人群，先忍忍，等过几天就换过去。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
